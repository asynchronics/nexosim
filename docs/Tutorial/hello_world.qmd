---
title: "Hello World"
filters:
  - line-highlight
---

In this section we will create a very basic simulation with a single model that
prints out "Hello World!" when it receives an event. Then we will set up a
server with the simulation so we can control the simulation through the python
client.

This will serve as an exploration of the general structure and usage of NeXosim.

-------

### Setting up a project

To start let's create a new project:

```bash
$ cargo new my-sim
$ cd my-sim
```

We need to add NeXosim to the project's dependencies. In `Cargo.toml` add
the following under `[dependencies]`.

```{.TOML}
nexosim = "0.3.2"
```

### Creating the model

With that out of the way, let's start building our simulation. First we need to
create a model. To do that write the following at the top of `main.rs`:

```{.rust}
use nexosim::model::Model;

struct HelloWorld;

impl HelloWorld {
    pub(crate) fn say_hello(&mut self) {
        println!("Hello World!");
    }
}

impl Model for HelloWorld {}
```
NeXosim models are types that implement the `nexosim::model::Model` trait. Here
we use the default implementation.

Our model, called `HelloWorld`, has a single input `say_hello`. Input ports are
methods with signatures for which the `InputFn` trait is implemented. We go into
further detail about model ports later in this tutorial.

### Building the simulation

To use our model we need to add it to a simulation and send an event to it to
see how it responds. First add the required use declarations right below the
first line:

```{.rust source-line-numbers="2,3"}
use nexosim::model::Model;
use nexosim::simulation::{Mailbox, SimInit};
use nexosim::time::MonotonicTime;
```

Then, replace the `main()` function with the following:

```{.rust}
fn main() {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let (mut sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)
        .unwrap();
}
```

First we instantiate the model and create a `Mailbox` for it. A mailbox is used
by the simulation to collect messages sent to its associated model. We keep the
mailbox's address, so we can later use it to send events to our model.

```{.rust source-line-numbers="2-4"}
fn main() {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let (mut sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)
        .unwrap();
}
```

We instantiate a `SimInit` object - a builder type for NeXosim simulations.

```{.rust source-line-numbers="6"}
fn main() {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let (mut sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)
        .unwrap();
}
```

Models are added to the simulation using the `SimInit::add_model()` method. We
call the method with the model, a mailbox that the simulation will associate
with the model, and a name as arguments.

The `name` parameter is used for error reporting to point to the model causing
the error, and, if the `tracing` feature is enabled, debugging from within the
model.

```{.rust source-line-numbers="7"}
fn main() {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let (mut sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)
        .unwrap();
}
```

The simulation is built using the `SimInit::init()` method. We arbitrarily
select `MonotonicTime::EPOCH` as the starting time of the simulation which
corresponds to `1970-01-01 00:00:00`.

The method returns a tuple with a `Simulation` and a `Scheduler`, wrapped in a
`Result` type. The simulation must be kept in a mutable variable for us to send
events to our model. We won't be using the scheduler in this section, so we can
ignore it for now.

```{.rust source-line-numbers="6,8,9"}
fn main() {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let (mut sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)
        .unwrap();
}
```

### Running the simulation

For the simulation, as currently set up, to do anything we need to send an event
to our model. Add this at the end of the `main()` function:

```rust
sim.process_event(HelloWorld::say_hello, (), addr).unwrap();
```

The statement sends an event to the `HelloWorld::say_hello` input port. The
event arg parameter is set to `()`, since `say_hello()` doesn't accept any
arguments. We need to provide the address we kept earlier as `addr`.

We can finally run our simulation by writing in the terminal from our project's
directory:

```bash
$ cargo run
```

which will print out:

```
Hello world!
```
## Trying out the server feature

NeXosim allows users to control simulations with a Python client. We can quickly
change our code to accommodate that.

### Setting up a simulation server

First we need to make sure that we are using NeXosim's `server` feature. Modify
the nexosim dependency line in `Cargo.toml` to:

```toml
nexosim = { version = "0.3.2", features = ["server"] }
```

Replace the use declaration at the top of `main.rs` with:

```rust
use nexosim::model::Model;
use nexosim::ports::EventSource;
use nexosim::registry::EndpointRegistry;
use nexosim::server;
use nexosim::simulation::{Mailbox, SimInit, Simulation, SimulationError};
use nexosim::time::MonotonicTime;
```

We will move the simulation set up to a new function above the `main()` definition:

```rust
fn simulation(_: ()) -> Result<(Simulation, EndpointRegistry), SimulationError> {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let mut input = EventSource::new();
    input.connect(HelloWorld::say_hello, addr);

    let mut registry = EndpointRegistry::new();
    registry.add_event_source(input, "say_hello").unwrap();

    let (sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)?;

    Ok((sim, registry))
}
```

The signature of the `simulation()` function is important. Functions that start
NeXosim simulation servers expect a function or closure that accepts one
argument and returns a built simulation and an endpoint registry.

The argument can be used to send setup configuration from the client during
initialization of the simulation. Here we don't need any additional data to
construct our simulation, so we just use `_: ()`.

```{.rust source-line-numbers="1"}
fn simulation(_: ()) -> Result<(Simulation, EndpointRegistry), SimulationError> {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let mut input = EventSource::new();
    input.connect(HelloWorld::say_hello, addr);

    let mut registry = EndpointRegistry::new();
    registry.add_event_source(input, "say_hello").unwrap();

    let (sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)?;

    Ok((sim, registry))
}
```

When using a simulation within a server, we need to define the available
endpoints that the server will expose. We instantiate an `EventSource` and
connect it to the `HelloWorld::say_hello` input. Event sources are endpoints
that allow us to send external events to simulation models' inputs.

```{.rust source-line-numbers="6,7"}
fn simulation(_: ()) -> Result<(Simulation, EndpointRegistry), SimulationError> {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let mut input = EventSource::new();
    input.connect(HelloWorld::say_hello, addr);

    let mut registry = EndpointRegistry::new();
    registry.add_event_source(input, "say_hello").unwrap();

    let (sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)?;

    Ok((sim, registry))
}
```

We also need to create an endpoint registry. The endpoint registry defines how
the client can interact with the simulation, because the server will only expose
endpoints inside the registry.

We add our event source under the name `"say_hello"`. We'll later be able to
send events to our model from the client using that name.

```{.rust source-line-numbers="9,10"}
fn simulation(_: ()) -> Result<(Simulation, EndpointRegistry), SimulationError> {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let mut input = EventSource::new();
    input.connect(HelloWorld::say_hello, addr);

    let mut registry = EndpointRegistry::new();
    registry.add_event_source(input, "say_hello").unwrap();

    let (sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)?;

    Ok((sim, registry))
}
```

We build the simulation the same way as earlier. The only changes from the
previous code is that we replaced the `unwrap()` call with error propagation
operator `?`, and we no longer need to keep the simulation object in an
immutable variable.

We return a tuple with the simulation and registry, wrapped in `Result::Ok`.

```{.rust source-line-numbers="12-16"}
fn simulation(_: ()) -> Result<(Simulation, EndpointRegistry), SimulationError> {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let mut input = EventSource::new();
    input.connect(HelloWorld::say_hello, addr);

    let mut registry = EndpointRegistry::new();
    registry.add_event_source(input, "say_hello").unwrap();

    let (sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)?;

    Ok((sim, registry))
}
```

The last thing we need to change on the server side is start the server with our
simulation in the `main()` function:

```rust
fn main() {
    server::run(simulation, "0.0.0.0:41633".parse().unwrap()).unwrap();
}
```

The `run` call starts a HTTP server listening  at `0.0.0.0:41366` set up with
our `simulation()` function. The server will call `simulation()` when it
receives an initialization request.

Alternatively, if using a unix system we can set up the server to use a unix
domain socket connection, by replacing the `server::run()` call with:

```rust
server::run_local(simulation, "/tmp/hello_world").unwrap();
```

### Creating the client

To use the python client we will create a `pip` virtual environment and install
`nexosim-py` in that environment.

In a terminal, from the project's directory, type out:

```bash
$ python -m venv venv
$ source ./venv/bin/activate
$ pip install nexosim-py
```

Let's create the new file `client.py` and write inside:

```{.python filename="client.py"}
from nexosim import Simulation

with Simulation("0.0.0.0:41633") as sim:
    sim.start()
    sim.process_event("say_hello")
```

The `Simulation` object is establishes a connection with the server during
construction. We pass the same address that we used when starting the server.

```{.python source-line-numbers="1,3"}
from nexosim import Simulation

with Simulation("0.0.0.0:41633") as sim:
    sim.start()
    sim.process_event("say_hello")
```

The `start()` method sends a initialization request to the server. This is where
we would include configuration data if the simulation expected any.

```{.python source-line-numbers="4"}
from nexosim import Simulation

with Simulation("0.0.0.0:41633") as sim:
    sim.start()
    sim.process_event("say_hello")
```

We call `Simulation.process_event()` to send an event to our model's input. When
sending an event from the client we use the name we set for the event source
when adding it to the endpoint registry.

```{.python source-line-numbers="5"}
from nexosim import Simulation

with Simulation("0.0.0.0:41633") as sim:
    sim.start()
    sim.process_event("say_hello")
```

It's time to test out our code. We can start the server by typing in a terminal
from our project's directory:

```bash
$ cargo run
```

We will run our client in a separate terminal:

```bash
$ source ./venv/bin/activate
$ python client.py
```

In the terminal that is running the server we should see printed out:

```
Hello World!
```

For more information about controlling NeXosim simulations using a Python client
refer to the
[nexosim-py documentation](https://nexosim-py.readthedocs.io/en/latest/).

## Finishing up

By the end of this section our code should look like this:

::: {.panel-tabset}

## Rust only

```{.rust filename="main.rs"}
use nexosim::model::Model;
use nexosim::simulation::{Mailbox, SimInit};
use nexosim::time::MonotonicTime;

struct HelloWorld;

impl HelloWorld {
    pub(crate) fn say_hello(&mut self) {
        println!("Hello World!");
    }
}

impl Model for HelloWorld {}

fn main() {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let (mut sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(MonotonicTime::EPOCH)
        .unwrap();

    sim.process_event(HelloWorld::say_hello, (), addr).unwrap();
}
```

## Server with a Python client

```{.rust filename="main.rs"}
use nexosim::model::Model;
use nexosim::simulation::{Mailbox, SimInit};
use nexosim::time::MonotonicTime;

struct HelloWorld;

impl HelloWorld {
    pub(crate) fn say_hello(&mut self) {
        println!("Hello World!");
    }
}

impl Model for HelloWorld {}

fn main() {
    let model = HelloWorld;
    let mbox = Mailbox::new();
    let addr = mbox.address();

    let t0 = MonotonicTime::EPOCH;

    let (mut sim, _) = SimInit::new()
        .add_model(model, mbox, "HELLO_WORLD")
        .init(t0)
        .unwrap();

    sim.process_event(HelloWorld::say_hello, (), addr).unwrap();
}
```

```{.python filename="run.py"}
from nexosim import Simulation

with Simulation("0.0.0.0:41366") as sim:
    sim.start()
    sim.process_event("say_hello")
```

:::