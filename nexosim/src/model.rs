//! Model components.
//!
//! # Models and model prototypes
//!
//! Every model must implement the [`trait@Model`] trait. This trait defines an
//! asynchronous initialization method, [`Model::init`], which main purpose is
//! to enable models to perform specific actions when the simulation starts,
//! *i.e.* after all models have been connected and added to the simulation.
//! [`Model::restore`] method is called whenever the model is restored from a
//! saved state.
//!
//! It is frequently convenient to expose to users a model builder type—called a
//! *model prototype*—rather than the final model. This can be done by
//! implementing the [`ProtoModel`] trait, which defines the associated model
//! type and a [`ProtoModel::build`] method invoked when a model is added the
//! simulation.
//!
//! Prototype models can be used whenever the Rust builder pattern is helpful,
//! for instance to set optional parameters. One of the use-cases that may
//! benefit from the use of prototype models is hierarchical model building.
//! When a parent model contains submodels, these submodels are often an
//! implementation detail that needs not be exposed to the user. One may then
//! define a prototype model that contains all outputs and requestors ports,
//! while the model itself contains the input and replier ports. Upon invocation
//! of [`ProtoModel::build`], the exit ports are moved to the model or its
//! submodels, and those submodels are added to the simulation.
//!
//! Note that a trivial [`ProtoModel`] implementation is generated by default
//! for any object implementing the [`trait@Model`] trait, provided its
//! [`Model::Env`] associated type implements [`Default`] trait. In such
//! case the associated [`ProtoModel::Model`] type is the model type itself.
//! This is what makes it possible to use either an explicitly-defined
//! [`ProtoModel`] as argument to
//! the [`SimInit::add_model`](crate::simulation::SimInit::add_model) method, or
//! a plain [`trait@Model`] type.
//!
//! In typical scenarios the [`trait@Model`] trait can be implemented
//! by a [`macro@Model`] proc-macro, applied to the main `impl` block of
//! the model struct. Methods such as `init` and `restore` can be provided by
//! using custom attributes (`#[nexosim(init)]` and `#[nexosim(restore)]`).
//! Moreover, input methods can be decorated with `#[nexosim(schedulable)]`
//! attribute to allow convenient self-scheduling within the model.
//!
//! #### Examples
//!
//! A model that does not require initialization or building can simply use the
//! default implementation of the [`trait@Model`] trait:
//!
//! ```
//! use nexosim::model::Model;
//!
//! use serde::{Serialize, Deserialize};
//!
//! #[derive(Serialize, Deserialize)]
//! pub struct MyModel {
//!     // ...
//! }
//! impl Model for MyModel {
//!     type Env = ();
//! }
//! ```
//!
//! If a default action is required during simulation initialization, the
//! [`Model::init`] method must be explicitly implemented. This is most commonly
//! done with the `#[nexosim(init)]` procedural macro helper attribute:
//!
//! ```
//! use nexosim::model::{Context, InitializedModel, Model};
//!
//! use serde::{Serialize, Deserialize};
//!
//! #[derive(Serialize, Deserialize)]
//! pub struct MyModel {
//!     // ...
//! }
//! #[Model]
//! impl MyModel {
//!     #[nexosim(init)]
//!     async fn init(
//!         mut self,
//!         ctx: &Context<Self>,
//!         env: &mut <MyModel as Model>::Env
//!     ) -> InitializedModel<Self> {
//!         println!("...initialization...");
//!
//!         self.into()
//!     }
//! }
//! ```
//!
//! When a model needs to schedule its own inputs, a `#[nexosim(schedulable)]`
//! attribute can be used to automatically register the method as schedulable.
//! Inputs decorated with this attribute can then be referred to using the
//! [`schedulable!`] macro:
//!
//! ```
//! use std::time::Duration;
//!
//! use serde::{Serialize, Deserialize};
//!
//! use nexosim::model::{schedulable, Context, InitializedModel, Model};
//!
//! #[derive(Serialize, Deserialize)]
//! pub struct MyModel {
//!     // ...
//! }
//! #[Model]
//! impl MyModel {
//!     #[nexosim(schedulable)]
//!     pub async fn input(&mut self) {
//!         // ...
//!     }
//!     #[nexosim(init)]
//!     async fn init(
//!         mut self,
//!         ctx: &Context<Self>,
//!         env: &mut <MyModel as Model>::Env
//!     ) -> InitializedModel<Self> {
//!         println!("...initialization...");
//!         ctx.schedule_event(Duration::from_secs(2), schedulable!(Self::input), ())
//!             .unwrap();
//!         self.into()
//!     }
//! }
//! ```
//!
//! Finally, if a model builder is required, the [`ProtoModel`] trait can be
//! explicitly implemented. Note that the [`ProtoModel`] contains all output and
//! requestor ports, while the associated [`trait@Model`] contains all input and
//! replier methods.
//!
//! ```
//! use nexosim::model::{BuildContext, InitializedModel, Model, ProtoModel};
//! use nexosim::ports::Output;
//!
//! use serde::{Serialize, Deserialize};
//!
//! /// The final model.
//! #[derive(Serialize, Deserialize)]
//! pub struct Multiplier {
//!     // Private outputs and requestors stored in a form that constitutes an
//!     // implementation detail and should not be exposed to the user.
//!     my_outputs: Vec<Output<usize>>
//! }
//! #[Model]
//! impl Multiplier {
//!     // Private constructor: the final model is built by the prototype model.
//!     fn new(
//!         value_times_1: Output<usize>,
//!         value_times_2: Output<usize>,
//!         value_times_3: Output<usize>,
//!     ) -> Self {
//!         Self {
//!             my_outputs: vec![value_times_1, value_times_2, value_times_3]
//!         }
//!     }
//!
//!     // Public input to be used during bench construction.
//!     pub async fn my_input(&mut self, my_data: usize) {
//!         for (i, output) in self.my_outputs.iter_mut().enumerate() {
//!             output.send(my_data*(i + 1)).await;
//!         }
//!     }
//! }
//!
//! pub struct ProtoMultiplier {
//!     // Prettyfied outputs exposed to the user.
//!     pub value_times_1: Output<usize>,
//!     pub value_times_2: Output<usize>,
//!     pub value_times_3: Output<usize>,
//! }
//! impl ProtoModel for ProtoMultiplier {
//!     type Model = Multiplier;
//!
//!     fn build(
//!         mut self,
//!         _: &mut BuildContext<Self>
//!     ) -> (Multiplier, ()) {
//!         (Multiplier::new(self.value_times_1, self.value_times_2, self.value_times_3), ())
//!     }
//! }
//! ```
//!
//! # Hierarchical models
//!
//! Hierarchical models are models build from a prototype, which prototype adds
//! submodels to the simulation within its [`ProtoModel::build`] method. From a
//! formal point of view, however, hierarchical models are just regular models
//! implementing the [`trait@Model`] trait, as are their submodels.
//!
//!
//! #### Example
//!
//! This example demonstrates a child model inside a parent model, where the
//! parent model simply forwards input data to the child and the child in turn
//! sends the data to the output exposed by the parent's prototype.
//!
//! For a more comprehensive example demonstrating hierarchical model
//! assemblies, see the [`assembly`][assembly] example.
//!
//! [assembly]:
//!     https://github.com/asynchronics/nexosim/tree/main/nexosim/examples/assembly.rs
//!
//! ```
//! use nexosim::model::{BuildContext, Model, ProtoModel};
//! use nexosim::ports::Output;
//! use nexosim::simulation::Mailbox;
//!
//! use serde::{Serialize, Deserialize};
//!
//! #[derive(Serialize, Deserialize)]
//! pub struct ParentModel {
//!     // Private internal port connected to the submodel.
//!     to_child: Output<u64>,
//! }
//! #[Model]
//! impl ParentModel {
//!     async fn input(&mut self, my_data: u64) {
//!         // Forward to the submodel.
//!         self.to_child.send(my_data).await;
//!     }
//! }
//!
//! pub struct ProtoParentModel {
//!     pub output: Output<u64>,
//! }
//! impl ProtoModel for ProtoParentModel {
//!     type Model = ParentModel;
//!
//!     fn build(self, cx: &mut BuildContext<Self>) -> (ParentModel, ()) {
//!         // Move the output to the child model.
//!         let child = ChildModel { output: self.output };
//!         let mut parent = ParentModel {
//!             to_child: Output::default(),
//!         };
//!
//!         let child_mailbox = Mailbox::new();
//!
//!         // Establish an internal Parent -> Child connection.
//!         parent
//!             .to_child
//!             .connect(ChildModel::input, child_mailbox.address());
//!
//!         // Add the child model to the simulation.
//!         cx.add_submodel(child, child_mailbox, "child");
//!
//!         (parent, ())
//!     }
//! }
//!
//! #[derive(Serialize, Deserialize)]
//! struct ChildModel {
//!     output: Output<u64>,
//! }
//! #[Model]
//! impl ChildModel {
//!     async fn input(&mut self, my_data: u64) {
//!         self.output.send(my_data).await;
//!     }
//! }
//! ```
use std::any::type_name;
use std::collections::VecDeque;
use std::future::Future;
use std::sync::Mutex;

use serde::{Serialize, de::DeserializeOwned};

use crate::path::Path;
use crate::ports::PORT_REG;
use crate::simulation::{
    Address, EVENT_KEY_REG, EventKeyReg, ExecutionError, RestoreError, SaveError, Simulation,
};
use crate::util::serialization::serialization_config;

pub use context::{BuildContext, Context, ModelRegistry, SchedulableId};
pub use nexosim_macros::{Model, schedulable};

mod context;

/// Trait to be implemented by simulation models.
///
/// This trait enables models to perform specific actions during initialization.
/// The [`Model::init`] method is run only once all models have been connected
/// and migrated to the simulation bench, but before the simulation actually
/// starts. A common use for `init` is to send messages to connected models at
/// the beginning of the simulation.
///
/// The `init` function converts the model to the opaque `InitializedModel` type
/// to prevent an already initialized model from being added to the simulation
/// bench.
///
/// Simiralily [`Model::restore`] method allows to perform actions when model is
/// restored from a saved state. It is run only once per simulation restore,
/// before it's run is resumed.
pub trait Model: Serialize + DeserializeOwned + Sized + Send + 'static {
    /// Helper struct for internal non-state model data that cannot (or should
    /// not) be serialized and persisted.
    type Env: Send + 'static;

    /// Performs asynchronous model initialization.
    ///
    /// This asynchronous method is executed exactly once for all models of the
    /// simulation when the
    /// [`SimInit::init`](crate::simulation::SimInit::init) method is called.
    /// It is not called after the model is restored from a serialized state.
    ///
    /// The default implementation simply converts the model to an
    /// `InitializedModel` without any side effect.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::future::Future;
    /// use std::pin::Pin;
    ///
    /// use serde::{Serialize, Deserialize};
    ///
    /// use nexosim::model::{Context, InitializedModel, Model};
    ///
    /// #[derive(Serialize, Deserialize)]
    /// pub struct MyModel {
    ///     // ...
    /// }
    ///
    /// impl Model for MyModel {
    ///     type Env = ();
    ///
    ///     async fn init(
    ///         self,
    ///         cx: &Context<Self>,
    ///         env: &mut Self::Env
    ///     ) -> InitializedModel<Self> {
    ///         println!("...initialization...");
    ///
    ///         self.into()
    ///     }
    /// }
    /// ```
    fn init(
        self,
        _: &Context<Self>,
        _: &mut Self::Env,
    ) -> impl Future<Output = InitializedModel<Self>> + Send {
        async { self.into() }
    }

    /// Initializes the model after it has been restored from a serialized
    /// state.
    ///
    /// This asynchronous method is executed exactly once for all models of the
    /// simulation when the
    /// [`SimInit::restore`](crate::simulation::SimInit::restore) method is
    /// called.
    ///
    /// The default implementation simply converts the model to an
    /// `InitializedModel` without any side effect.
    fn restore(
        self,
        _: &Context<Self>,
        _: &mut Self::Env,
    ) -> impl Future<Output = InitializedModel<Self>> + Send {
        async { self.into() }
    }

    /// Generates the model's registry's of self-schedulable inputs.
    ///
    /// This is exclusively used by the [`macro@Model`] procedural macro and is
    /// not meant for manual implementation.
    fn register_schedulables(_: &mut BuildContext<impl ProtoModel<Model = Self>>) -> ModelRegistry {
        ModelRegistry::default()
    }
}

/// Opaque type containing an initialized model.
///
/// A model can be converted to an `InitializedModel` using the `Into`/`From`
/// traits. The implementation of the simulation guarantees that the
/// [`Model::init`] method will never be called on a model after conversion to
/// an `InitializedModel`.
#[derive(Debug)]
pub struct InitializedModel<M: Model>(pub(crate) M);

impl<M: Model> From<M> for InitializedModel<M> {
    fn from(model: M) -> Self {
        InitializedModel(model)
    }
}

/// Trait to be implemented by simulation model prototypes.
///
/// This trait makes it possible to build the final model from a builder type
/// when it is added to the simulation.
///
/// The [`ProtoModel::build`] method consumes the prototype. It is
/// automatically called when a model or submodel prototype is added to the
/// simulation using
/// [`Simulation::add_model`](crate::simulation::SimInit::add_model) or
/// [`BuildContext::add_submodel`].
pub trait ProtoModel: Sized {
    /// Type of the model to be built.
    type Model: Model;

    /// Builds the model.
    ///
    /// This method is invoked when the
    /// [`SimInit::add_model`](crate::simulation::SimInit::add_model) or
    /// [`BuildContext::add_submodel`] method are called.
    fn build(self, cx: &mut BuildContext<Self>) -> (Self::Model, <Self::Model as Model>::Env);
}

// Every model can be used as a prototype for itself,
// if it's environment implements [`Default`] trait.
impl<M: Model<Env = E>, E: Default> ProtoModel for M {
    type Model = Self;

    fn build(self, _: &mut BuildContext<Self>) -> (Self::Model, <Self::Model as Model>::Env) {
        (self, E::default())
    }
}

/// An internal helper struct used to handle (de)serialization of the models.
pub(crate) struct RegisteredModel {
    pub path: Path,
    #[allow(clippy::type_complexity)]
    pub serialize: Box<dyn Fn(&mut Simulation) -> Result<Vec<u8>, ExecutionError> + Send>,
    #[allow(clippy::type_complexity)]
    pub deserialize:
        Box<dyn Fn(&mut Simulation, (Vec<u8>, EventKeyReg)) -> Result<(), ExecutionError> + Send>,
}
impl RegisteredModel {
    pub(crate) fn new<M: Model>(path: Path, address: Address<M>) -> Self {
        let ser_address = address.clone();
        let de_address = address.clone();
        let ser_path = path.clone();
        let de_path = path.clone();

        let serialize = Box::new(move |sim: &mut Simulation| {
            sim.process_replier_fn(serialize_model, ser_path.clone(), &ser_address)?
        });
        let deserialize = Box::new(move |sim: &mut Simulation, state: (Vec<u8>, EventKeyReg)| {
            sim.process_replier_fn(
                deserialize_model,
                (state.0, state.1, de_path.clone()),
                &de_address,
            )?
        });
        Self {
            path,
            serialize,
            deserialize,
        }
    }
}

impl std::fmt::Debug for RegisteredModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Registered Model")
            .field("path", &self.path)
            .finish_non_exhaustive()
    }
}

pub(crate) async fn serialize_model<M: Model>(
    model: &mut M,
    path: Path,
) -> Result<Vec<u8>, ExecutionError> {
    bincode::serde::encode_to_vec(model, serialization_config()).map_err(|e| {
        SaveError::ModelSerializationError {
            model: path,
            type_name: type_name::<M>(),
            cause: Box::new(e),
        }
        .into()
    })
}

pub(crate) async fn deserialize_model<M: Model>(
    model: &mut M,
    state: (Vec<u8>, EventKeyReg, Path),
    cx: &Context<M>,
    env: &mut M::Env,
) -> Result<(), ExecutionError> {
    let restored = PORT_REG
        .set(&Mutex::new(VecDeque::new()), || {
            EVENT_KEY_REG.set(&state.1, || {
                bincode::serde::encode_to_vec(&model, serialization_config()).map_err(|e| {
                    RestoreError::ModelSerializationError {
                        model: state.2.clone(),
                        type_name: type_name::<M>(),
                        cause: Box::new(e),
                    }
                })?;
                bincode::serde::borrow_decode_from_slice::<M, _>(&state.0, serialization_config())
                    .map_err(|e| RestoreError::ModelDeserializationError {
                        model: state.2,
                        type_name: type_name::<M>(),
                        cause: Box::new(e),
                    })
            })
        })?
        .0;
    let restored = restored.restore(cx, env).await.0;
    let _ = std::mem::replace(model, restored);
    Ok(())
}

/// Type alias for the generated schema type.
pub type MessageSchema = String;

/// An optional helper trait for event and query input / output arguments.
/// Enables json schema generation to precisely describe the types of exchanged
/// data.
pub trait Message {
    /// Returns a schema defining message type.
    fn schema() -> MessageSchema;
}
impl<T> Message for T
where
    T: crate::JsonSchema,
{
    fn schema() -> MessageSchema {
        schemars::schema_for!(T).as_value().to_string()
    }
}
