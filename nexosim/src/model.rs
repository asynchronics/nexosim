//! Model components.
//!
//! # Models and model prototypes
//!
//! Every model must implement the [`Model`] trait. This trait defines an
//! asynchronous initialization method, [`Model::init`], which main purpose is
//! to enable models to perform specific actions when the simulation starts,
//! *i.e.* after all models have been connected and added to the simulation.
//! [`Model::restore`] method is called whenever the model is restored from a
//! saved state.
//!
//! It is frequently convenient to expose to users a model builder type—called a
//! *model prototype*—rather than the final model. This can be done by
//! implementing the [`ProtoModel`] trait, which defines the associated model
//! type and a [`ProtoModel::build`] method invoked when a model is added the
//! simulation.
//!
//! Prototype models can be used whenever the Rust builder pattern is helpful,
//! for instance to set optional parameters. One of the use-cases that may
//! benefit from the use of prototype models is hierarchical model building.
//! When a parent model contains submodels, these submodels are often an
//! implementation detail that needs not be exposed to the user. One may then
//! define a prototype model that contains all outputs and requestors ports,
//! while the model itself contains the input and replier ports. Upon invocation
//! of [`ProtoModel::build`], the exit ports are moved to the model or its
//! submodels, and those submodels are added to the simulation.
//!
//! Note that a trivial [`ProtoModel`] implementation is generated by default
//! for any object implementing the [`Model`] trait, provided its [`Model::Env`]
//! associated type implements [`Default`] trait. In such
//! case the associated [`ProtoModel::Model`] type is the model type itself.
//! This is what makes it possible to use either an explicitly-defined
//! [`ProtoModel`] as argument to
//! the [`SimInit::add_model`](crate::simulation::SimInit::add_model) method, or
//! a plain [`Model`] type.
//!
//! In typical scenarios the [`Model`] trait can be implemented
//! by a [`Model`](crate::Model) proc-macro, applied to the main `impl` block of
//! the model struct. Methods such as `init` and `restore` can be provided by
//! using custom attributes (`#[nexosim(init)]` and `#[nexosim(restore)]`).
//! Moreover, input methods can be decorated with `#[nexosim(schedulable)]`
//! attribute to allow convenient self-scheduling within the model.
//!
//! #### Examples
//!
//! A model that does not require initialization or building can simply use the
//! default implementation of the [`Model`] trait:
//!
//! ```
//! use nexosim::model::Model;
//!
//! use serde::{Serialize, Deserialize};
//!
//! #[derive(Serialize, Deserialize)]
//! pub struct MyModel {
//!     // ...
//! }
//! impl Model for MyModel {
//!     type Env = ();
//! }
//! ```
//!
//! If a default action is required during simulation initialization, the `init`
//! methods can be explicitly implemented (here using a proc-macro helper
//! attribute):
//!
//! ```
//! use nexosim::model::{Context, InitializedModel};
//! use nexosim::Model;
//!
//! use serde::{Serialize, Deserialize};
//!
//! #[derive(Serialize, Deserialize)]
//! pub struct MyModel {
//!     // ...
//! }
//! #[Model]
//! impl MyModel {
//!     #[nexosim(init)]
//!     async fn init(
//!         mut self,
//!         ctx: &mut Context<Self>
//!     ) -> InitializedModel<Self> {
//!         println!("...initialization...");
//!
//!         self.into()
//!     }
//! }
//! ```
//!
//! Whenever it is needed for a model to schedule its own inputs, a
//! #[nexosim(schedulable)] attribute can be used to automatically register the method.
//! Inputs decorated with the attribute need to be referred via
//! [`schedulable!`](crate::schedulable) macro when passed to the scheduler.
//!
//! ```
//! use std::time::Duration;
//!
//! use serde::{Serialize, Deserialize};
//!
//! use nexosim::model::{Context, InitializedModel};
//! use nexosim::{schedulable, Model};
//!
//! #[derive(Serialize, Deserialize)]
//! pub struct MyModel {
//!     // ...
//! }
//! #[Model]
//! impl MyModel {
//!     #[nexosim(schedulable)]
//!     pub async fn input(&mut self) {
//!         // ...
//!     }
//!     #[nexosim(init)]
//!     async fn init(
//!         mut self,
//!         ctx: &mut Context<Self>
//!     ) -> InitializedModel<Self> {
//!         println!("...initialization...");
//!         ctx.schedule_event(Duration::from_secs(2), schedulable!(Self::input), ())
//!             .unwrap();
//!         self.into()
//!     }
//! }
//! ```
//!
//! Finally, if a model builder is required, the [`ProtoModel`] trait can be
//! explicitly implemented. Note that the [`ProtoModel`] contains all output and
//! requestor ports, while the associated [`Model`] contains all input and
//! replier methods.
//!
//! ```
//! use nexosim::model::{BuildContext, InitializedModel, ProtoModel};
//! use nexosim::ports::Output;
//! use nexosim::Model;
//!
//! use serde::{Serialize, Deserialize};
//!
//! /// The final model.
//! #[derive(Serialize, Deserialize)]
//! pub struct Multiplier {
//!     // Private outputs and requestors stored in a form that constitutes an
//!     // implementation detail and should not be exposed to the user.
//!     my_outputs: Vec<Output<usize>>
//! }
//! #[Model]
//! impl Multiplier {
//!     // Private constructor: the final model is built by the prototype model.
//!     fn new(
//!         value_times_1: Output<usize>,
//!         value_times_2: Output<usize>,
//!         value_times_3: Output<usize>,
//!     ) -> Self {
//!         Self {
//!             my_outputs: vec![value_times_1, value_times_2, value_times_3]
//!         }
//!     }
//!
//!     // Public input to be used during bench construction.
//!     pub async fn my_input(&mut self, my_data: usize) {
//!         for (i, output) in self.my_outputs.iter_mut().enumerate() {
//!             output.send(my_data*(i + 1)).await;
//!         }
//!     }
//! }
//!
//! pub struct ProtoMultiplier {
//!     // Prettyfied outputs exposed to the user.
//!     pub value_times_1: Output<usize>,
//!     pub value_times_2: Output<usize>,
//!     pub value_times_3: Output<usize>,
//! }
//! impl ProtoModel for ProtoMultiplier {
//!     type Model = Multiplier;
//!
//!     fn build(
//!         mut self,
//!         _: &mut BuildContext<Self>
//!     ) -> (Multiplier, ()) {
//!         (Multiplier::new(self.value_times_1, self.value_times_2, self.value_times_3), ())
//!     }
//! }
//! ```
//!
//! # Hierarchical models
//!
//! Hierarchical models are models build from a prototype, which prototype adds
//! submodels to the simulation within its [`ProtoModel::build`] method. From a
//! formal point of view, however, hierarchical models are just regular models
//! implementing the [`Model`] trait, as are their submodels.
//!
//!
//! #### Example
//!
//! This example demonstrates a child model inside a parent model, where the
//! parent model simply forwards input data to the child and the child in turn
//! sends the data to the output exposed by the parent's prototype.
//!
//! For a more comprehensive example demonstrating hierarchical model
//! assemblies, see the [`assembly`][assembly] example.
//!
//! [assembly]:
//!     https://github.com/asynchronics/nexosim/tree/main/nexosim/examples/assembly.rs
//!
//! ```
//! use nexosim::model::{BuildContext, ProtoModel};
//! use nexosim::ports::Output;
//! use nexosim::simulation::Mailbox;
//! use nexosim::Model;
//!
//! use serde::{Serialize, Deserialize};
//!
//! #[derive(Serialize, Deserialize)]
//! pub struct ParentModel {
//!     // Private internal port connected to the submodel.
//!     to_child: Output<u64>,
//! }
//! #[Model]
//! impl ParentModel {
//!     async fn input(&mut self, my_data: u64) {
//!         // Forward to the submodel.
//!         self.to_child.send(my_data).await;
//!     }
//! }
//!
//! pub struct ProtoParentModel {
//!     pub output: Output<u64>,
//! }
//! impl ProtoModel for ProtoParentModel {
//!     type Model = ParentModel;
//!
//!     fn build(self, cx: &mut BuildContext<Self>) -> (ParentModel, ()) {
//!         // Move the output to the child model.
//!         let child = ChildModel { output: self.output };
//!         let mut parent = ParentModel {
//!             to_child: Output::default(),
//!         };
//!
//!         let child_mailbox = Mailbox::new();
//!
//!         // Establish an internal Parent -> Child connection.
//!         parent
//!             .to_child
//!             .connect(ChildModel::input, child_mailbox.address());
//!
//!         // Add the child model to the simulation.
//!         cx.add_submodel(child, child_mailbox, "child");
//!
//!         (parent, ())
//!     }
//! }
//!
//! #[derive(Serialize, Deserialize)]
//! struct ChildModel {
//!     output: Output<u64>,
//! }
//! #[Model]
//! impl ChildModel {
//!     async fn input(&mut self, my_data: u64) {
//!         self.output.send(my_data).await;
//!     }
//! }
//! ```
use std::any::type_name;
use std::collections::VecDeque;
use std::future::Future;
use std::sync::Mutex;

use serde::{de::DeserializeOwned, Serialize};

use crate::ports::PORT_REG;
use crate::simulation::{Address, EventKeyReg, ExecutionError, Simulation, EVENT_KEY_REG};
use crate::util::serialization::serialization_config;

pub use context::{BuildContext, Context, ModelRegistry, SchedulableId};

mod context;

/// Trait to be implemented by simulation models.
///
/// This trait enables models to perform specific actions during initialization.
/// The [`Model::init`] method is run only once all models have been connected
/// and migrated to the simulation bench, but before the simulation actually
/// starts. A common use for `init` is to send messages to connected models at
/// the beginning of the simulation.
///
/// The `init` function converts the model to the opaque `InitializedModel` type
/// to prevent an already initialized model from being added to the simulation
/// bench.
///
/// Simiralily [`Model::restore`] method allows to perform actions when model is
/// restored from a saved state. It is run only once per simulation restore,
/// before it's run is resumed.
pub trait Model: Serialize + DeserializeOwned + Sized + Send + 'static {
    /// Helper struct for internal non-state model data that cannot (or should
    /// not) be serialized and persisted.
    type Env: Send + 'static;

    /// Performs asynchronous model initialization.
    ///
    /// This asynchronous method is executed exactly once for all models of the
    /// simulation when the
    /// [`SimInit::init`](crate::simulation::SimInit::init) method is called.
    /// It is not called after the model is restored from a serialized state.
    ///
    /// The default implementation simply converts the model to an
    /// `InitializedModel` without any side effect.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::future::Future;
    /// use std::pin::Pin;
    ///
    /// use serde::{Serialize, Deserialize};
    ///
    /// use nexosim::model::{Context, InitializedModel, Model};
    ///
    /// #[derive(Serialize, Deserialize)]
    /// pub struct MyModel {
    ///     // ...
    /// }
    ///
    /// impl Model for MyModel {
    ///     type Env = ();
    ///
    ///     async fn init(
    ///         self,
    ///         cx: &mut Context<Self>
    ///     ) -> InitializedModel<Self> {
    ///         println!("...initialization...");
    ///
    ///         self.into()
    ///     }
    /// }
    /// ```
    fn init(self, _: &mut Context<Self>) -> impl Future<Output = InitializedModel<Self>> + Send {
        async { self.into() }
    }

    /// Reinitialization method called after model has been restored from a
    /// serialized state.
    ///
    /// This asynchronous method is executed exactly once for all models of the
    /// simulation when the
    /// [`SimInit::restore`](crate::simulation::SimInit::restore) method is
    /// called.
    ///
    /// The default implementation simply converts the model to an
    /// `InitializedModel` without any side effect.
    fn restore(self, _: &mut Context<Self>) -> impl Future<Output = InitializedModel<Self>> + Send {
        async { self.into() }
    }

    /// Creates model's internal input registry used for self-scheduling.
    /// Typically it should not be implemented manually, as it is generated by
    /// the [`Model`](crate::Model) proc-macro.
    fn register_schedulables(
        &mut self,
        _: &mut BuildContext<impl ProtoModel<Model = Self>>,
    ) -> ModelRegistry {
        ModelRegistry::default()
    }
}

/// Opaque type containing an initialized model.
///
/// A model can be converted to an `InitializedModel` using the `Into`/`From`
/// traits. The implementation of the simulation guarantees that the
/// [`Model::init`] method will never be called on a model after conversion to
/// an `InitializedModel`.
#[derive(Debug)]
pub struct InitializedModel<M: Model>(pub(crate) M);

impl<M: Model> From<M> for InitializedModel<M> {
    fn from(model: M) -> Self {
        InitializedModel(model)
    }
}

/// Trait to be implemented by simulation model prototypes.
///
/// This trait makes it possible to build the final model from a builder type
/// when it is added to the simulation.
///
/// The [`ProtoModel::build`] method consumes the prototype. It is
/// automatically called when a model or submodel prototype is added to the
/// simulation using
/// [`Simulation::add_model`](crate::simulation::SimInit::add_model) or
/// [`BuildContext::add_submodel`].
pub trait ProtoModel: Sized {
    /// Type of the model to be built.
    type Model: Model;

    /// Builds the model.
    ///
    /// This method is invoked when the
    /// [`SimInit::add_model`](crate::simulation::SimInit::add_model) or
    /// [`BuildContext::add_submodel`] method are called.
    fn build(self, cx: &mut BuildContext<Self>) -> (Self::Model, <Self::Model as Model>::Env);
}

// Every model can be used as a prototype for itself,
// if it's environment implements [`Default`] trait.
impl<M: Model<Env = E>, E: Default> ProtoModel for M {
    type Model = Self;

    fn build(self, _: &mut BuildContext<Self>) -> (Self::Model, <Self::Model as Model>::Env) {
        (self, E::default())
    }
}

/// An internal helper struct used to handle (de)serialization of the models.
pub(crate) struct RegisteredModel {
    pub name: String,
    #[allow(clippy::type_complexity)]
    pub serialize: Box<dyn Fn(&mut Simulation) -> Result<Vec<u8>, ExecutionError> + Send>,
    #[allow(clippy::type_complexity)]
    pub deserialize:
        Box<dyn Fn(&mut Simulation, (Vec<u8>, EventKeyReg)) -> Result<(), ExecutionError> + Send>,
}
impl RegisteredModel {
    pub(crate) fn new<M: Model>(name: String, address: Address<M>) -> Self {
        let ser_address = address.clone();
        let de_address = address.clone();
        let ser_name = name.clone();
        let de_name = name.clone();

        let serialize = Box::new(move |sim: &mut Simulation| {
            sim.process_query(serialize_model, ser_name.clone(), &ser_address)?
        });
        let deserialize = Box::new(move |sim: &mut Simulation, state: (Vec<u8>, EventKeyReg)| {
            sim.process_query(
                deserialize_model,
                (state.0, state.1, de_name.clone()),
                &de_address,
            )?
        });
        Self {
            name,
            serialize,
            deserialize,
        }
    }
}

impl std::fmt::Debug for RegisteredModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Registered Model")
            .field("name", &self.name)
            .finish_non_exhaustive()
    }
}

async fn serialize_model<M: Model>(model: &mut M, name: String) -> Result<Vec<u8>, ExecutionError> {
    bincode::serde::encode_to_vec(model, serialization_config())
        .map_err(|_| ExecutionError::SaveError(format!("Model: {} ({})", name, type_name::<M>())))
}

async fn deserialize_model<M: Model>(
    model: &mut M,
    state: (Vec<u8>, EventKeyReg, String),
    cx: &mut Context<M>,
) -> Result<(), ExecutionError> {
    let restored = PORT_REG
        .set(&Mutex::new(VecDeque::new()), || {
            EVENT_KEY_REG.set(&state.1, || {
                bincode::serde::encode_to_vec(&model, serialization_config()).map_err(|_| {
                    ExecutionError::RestoreError(format!(
                        "Model: {} ({})",
                        state.2,
                        type_name::<M>()
                    ))
                })?;

                bincode::serde::borrow_decode_from_slice::<M, _>(&state.0, serialization_config())
                    .map_err(|_| {
                        ExecutionError::RestoreError(format!(
                            "Model: {} ({})",
                            state.2,
                            type_name::<M>()
                        ))
                    })
            })
        })?
        .0;
    let restored = restored.restore(cx).await.0;
    let _ = std::mem::replace(model, restored);
    Ok(())
}
